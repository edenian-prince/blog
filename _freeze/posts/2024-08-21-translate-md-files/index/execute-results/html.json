{
  "hash": "e423fbf13f83715c021937666f1d502c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Translating Quarto (and other markdown files) into Any Language\ndescription: Translating the language of the text, not the programming language!\ndate: 2024-8-21\ndate-modified: last-modified\nauthor: Frank Aragona\ncategories:\n  - translation\nformat:\n  nwpage-html:\n    toc: true\n---\n\n::: {.cell}\n<style type=\"text/css\">\n// Output colors\n.watch {\n  background-color: lightpurple;\n  border: 3px solid purple;\n  font-weight: bold;\n}\n</style>\n:::\n\n::: {.cell}\n\n:::\n\n\n\n\n# Multilingual Quarto \n\nI made a simple workflow for translating the text of a qmd file (or really any md file) into a new language. I'll use English to Spanish as an example.\n\n\n# ü§ó Hugging Face Transformers\n\nThe first step is to find a model that can translate into whatever language we want. I looked into a few different apis (like Google, DeepL), but they all required a credit card on file (even free versions), an api token, and they all have a tier approach where you can only make so many api calls. \n\nI wanted to **simplfy everything** and avoid putting my credit card into any browser. Queue **[Hugging Face Transformers](https://huggingface.co/docs/transformers/en/index)**\n\n\n> Transformers provides APIs and tools to easily download and train state-of-the-art pretrained models. Using pretrained models can reduce your compute costs, carbon footprint, and save you the time and resources required to train a model from scratch. These models support common tasks in different modalities, such as:\n\n>üìù Natural Language Processing: text classification, named entity recognition, question answering, language modeling, summarization, translation, multiple choice, and text generation.\n>üñºÔ∏è Computer Vision: image classification, object detection, and segmentation.\n>üó£Ô∏è Audio: automatic speech recognition and audio classification.\n>üêô Multimodal: table question answering, optical character recognition, information extraction from scanned documents, video classification, and visual question answering.\n\n# Code to use Transformers\n\nThere is an [R library for hugging face](https://github.com/farach/huggingfaceR), but I think it requires conda to install some python libraries and I had conda issues, so I just made a [more simple package](https://github.com/edenian-prince/translatemd) that uses pip to install the python dependencies. And this package is really only for translation and for this demo.\n\nI originally did all of this in Python, but decided to convert everything I could into R because parsing an md file is surprisingly (or unsurprisingly?) way more straightforward in R, and that's where the real magic happens.\n\n:::{.panel-tabset}\n\n\n## install\n\n- first install reticulate,\n- then the package\n- and then you need to install the python dependencies\n\nreticulate:\n\n:::{.smallframe}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# you need reticulate to use the python code\nrenv::install('reticulate')\n```\n:::\n\n\n:::\n\n\npackage: \n\n:::{.medframe}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install my package\nremotes::install_github('edenian-prince/translatemd')\n```\n:::\n\n\n:::\n\n\npython dependencies: \n\nThis will install a separated virtual environment called `r-transformers` but you can rename it and specify the location of the venv if you want. It will then pip install `torch`, `transformers` and `sentencepiece`\n\n:::{.medframe}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntranslatemd::install_transformers()\n```\n:::\n\n\n:::\n\n\nGetting started, this video helped a ton!\n\n\n\n{{< video https://www.youtube.com/watch?v=feA-H6blwr4 >}}\n\n\n\n\n\n\n## select language\n\nHere you need to find a [NLP translation model](https://huggingface.co/models?pipeline_tag=translation&sort=trending) from Hugging Face. I recommend the [Helsinki models](https://huggingface.co/models?pipeline_tag=translation&sort=trending&search=helsinki) \n\nWhen you find a model you want, copy the entire model name and paste it as a string into the function below, like this for the spanish model:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntranslator <- translatemd::select_lang(\"Helsinki-NLP/opus-mt-en-es\")\n```\n:::\n\n\n\n:::{.callout-note}\nNote that the models are written like _from xx to yy_ so in this case it's _en-es_ which is _english to spanish_\n:::\n\n## translate\n\nYou can input text in the translate function and it will translate english to spanish:\n\n:::{.medframe}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntranslatemd::translate('Hello, my name is Frank')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n``` watch\n[1] \"Hola, mi nombre es Frank.\"\n```\n\n\n:::\n:::\n\n\n:::\n\n:::\n\n\n\n# Translate an Entire QMD File\n\n- Parse the QMD\n- Apply the translate function to the text\n- Re-write the translated QMD into a new document\n\n## md parse\n\nThe `lightparser` package is fantastic (and light!). It will take the qmd or rmd and return a tibble of its elements.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(parsed <- lightparser::split_to_tbl('_english.qmd'))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nIt seems you are currently knitting a Rmd/Qmd file. The parsing of the file will be done in a new R session.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n``` watch\n# A tibble: 8 √ó 8\n  type    label           params       text  code  heading heading_level section\n  <chr>   <chr>           <list>       <nam> <lis> <chr>           <dbl> <chr>  \n1 yaml    <NA>            <named list> <lgl> <lgl> <NA>               NA <NA>   \n2 inline  <NA>            <lgl [1]>    <chr> <lgl> <NA>               NA <NA>   \n3 heading <NA>            <lgl [1]>    <chr> <lgl> Quarto              1 Quarto \n4 inline  <NA>            <lgl [1]>    <chr> <lgl> <NA>               NA Quarto \n5 heading <NA>            <lgl [1]>    <chr> <lgl> Automa‚Ä¶             1 Automa‚Ä¶\n6 inline  <NA>            <lgl [1]>    <chr> <lgl> <NA>               NA Automa‚Ä¶\n7 block   unnamed-chunk-1 <named list> <lgl> <chr> <NA>               NA Automa‚Ä¶\n8 inline  <NA>            <lgl [1]>    <chr> <lgl> <NA>               NA Automa‚Ä¶\n```\n\n\n:::\n:::\n\n\n\n## md translate\n\nunnest the text and apply the translate function\n\n:::{.medframe}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparsed_es <- parsed |>\n  tidyr::unnest(cols = text) |>\n  dplyr::mutate(text_es = \n    purrr::map(text,translatemd::translate)\n  )\n```\n:::\n\n\n:::\n\n\nlet's see what it looks like.\n\n\n\n\n::: {.cell .column-screen-inset-shaded layout-nrow=\"1\"}\n\n```{.r .cell-code}\nparsed_es |>\n  tidyr::unnest(cols = text_es) |>\n  dplyr::select(type,text) |>\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 √ó 2\n  type    text                                                                  \n  <chr>   <chr>                                                                 \n1 heading # Quarto                                                              \n2 inline  Quarto enables you to weave together content and executable code into‚Ä¶\n3 inline  To create the release cycle in your repo you may want to use Conventi‚Ä¶\n4 inline  Conventional Commits are a way to format and standardize your commit ‚Ä¶\n5 inline  -   The word `feat:` can trigger a Github Action to add that commit t‚Ä¶\n6 inline  -   and it will up-version the minor release version number.          \n```\n\n\n:::\n\n```{.r .cell-code}\nparsed_es |>\n  tidyr::unnest(cols = text_es) |>\n  dplyr::select(type,text_es) |>\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 √ó 2\n  type    text_es                                                               \n  <chr>   <chr>                                                                 \n1 heading # Quarto                                                              \n2 inline  Quarto le permite entretejer el contenido y el c√≥digo ejecutable en u‚Ä¶\n3 inline  Para crear el ciclo de lanzamiento en su repo es posible que desee ut‚Ä¶\n4 inline  Commits convencionales son una forma de formatear y estandarizar sus ‚Ä¶\n5 inline  - La palabra `feat:` puede activar una acci√≥n de Github para a√±adir q‚Ä¶\n6 inline  - y subir√° el n√∫mero de versi√≥n de lanzamiento menor.                 \n```\n\n\n:::\n:::\n\n\n\n\n\n## write to new qmd\n\nclean up and write to new\n\n:::{.medframe}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparsed_es_to_qmd <- parsed_es |>\n  dplyr::select(-text) |>\n  dplyr::rename(text = text_es)\n\n# output to qmd\nlightparser::combine_tbl_to_file(\n  parsed_es_to_qmd,\n  \"_spanish.qmd\"\n)\n```\n:::\n\n\n:::\n\n# Results\n\nAnd now you have a document in English and another in Spanish\n\n:::{.column-screen-inset-shaded layout-nrow=\"1\"}\n\n![](images/english.png){.myframe}\n\n![](images/spanish.png){.myframe}\n\n\n:::\n\n\n# Bugs\n\nI've caught a few bugs to this approach and you maybe even noticed some!\n\n1. A `#` got removed in the translate - look at the section called `Automating the Release Cycle`. Since the `#` got removed it is no longer a header ‚òπÔ∏è\n2. The `lightparser` package has [a reported bug](https://github.com/ThinkR-open/lightparser/issues/13) with quarto chunk yaml parameters. Here it converted `#| eval: false` into `#| eval: no`, but we know that the `#| eval: false` should not be treated as text. Hopefully this is fixed\n\nI recommend going through the document and looking for bugs like these! Some manual edits to the translated qmd file may be necessary. \n\n\n# Full Script Example\n\n\n\n::: {.cell filename='translate.R'}\n\n```{.r .cell-code}\n# install\ntranslatemd::install_transformers()\n\n# select language\ntranslator <- translatemd::select_lang(\"Helsinki-NLP/opus-mt-en-es\")\n\n# parse your qmd\n(parsed <- lightparser::split_to_tbl('english.qmd'))\n\n# translate the qmd\nparsed_es <- parsed |>\n  tidyr::unnest(cols = text) |>\n  dplyr::mutate(text_es = purrr::map(text,translatemd::translate))\n\n# write to a new qmd\nparsed_es_to_qmd <- parsed_es |>\n  dplyr::select(-text) |>\n  dplyr::rename(text = text_es)\n\n# output to qmd\nlightparser::combine_tbl_to_file(\n  parsed_es_to_qmd,\n  \"_spanish.qmd\"\n)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}